import { Processor, Process, OnQueueFailed } from '@nestjs/bull';
import type { Job } from 'bull';
import { InjectModel } from '@nestjs/mongoose';
import type { Model } from 'mongoose';
import { Types } from 'mongoose';
import { QueueName } from './queue.names';
import type { AIGenerationJobData } from './queue.names';
import { SummaryGenerator } from '../generators/summary.generator';
import { FindingsGenerator } from '../generators/findings.generator';
import { RecommendationsGenerator } from '../generators/recommendations.generator';
import { ProgressService } from './progress.service';
import { DeadLetterService } from './dead-letter.service';
import { Form } from '../../schemas/form.schema';
import type { FormDocument } from '../../schemas/form.schema';
import { Response } from '../../schemas/response.schema';
import type { ResponseDocument } from '../../schemas/response.schema';

@Processor(QueueName.AI_GENERATION)
export class AIGenerationConsumer {
  constructor(
    private readonly summaryGenerator: SummaryGenerator,
    private readonly findingsGenerator: FindingsGenerator,
    private readonly recommendationsGenerator: RecommendationsGenerator,
    private readonly progressService: ProgressService,
    private readonly deadLetterService: DeadLetterService,
    @InjectModel(Form.name) private readonly formModel: Model<FormDocument>,
    @InjectModel(Response.name) private readonly responseModel: Model<ResponseDocument>,
  ) {}

  @Process({ name: 'generate-summary', concurrency: 3 })
  async handleSummary(job: Job<AIGenerationJobData>) {
    const { taskId, formId } = job.data;
    
    await this.progressService.publishProgress({
      taskId,
      type: 'progress',
      message: 'Generating executive summary...',
      progress: 76,
    });

    // Load form and responses
    const form = await this.formModel.findById(formId).exec();
    if (!form || !form.analytics) {
      throw new Error('Form or analytics not found');
    }

    const responses = await this.responseModel.find({
      formId: new Types.ObjectId(formId),
      'metadata.processedForAnalytics': true,
    }).exec();

    // Extract data from form.analytics
    const topTopics = form.analytics.topics?.topTopics || [];
    const sentimentDistribution = form.analytics.sentiment?.overall || { positive: 0, neutral: 0, negative: 0, averageScore: 0 };
    const representativeQuotes = form.analytics.quotes?.representative || [];
    
    // Use existing key findings from form.analytics if available, otherwise use empty array
    // Key findings are generated by the separate 'generate-findings' job
    const keyFindings = form.analytics.insights?.keyFindings || [];

    // Use existing recommendations from form.analytics if available, otherwise use empty array
    // Recommendations are generated by the separate 'generate-recommendations' job
    const recommendations = form.analytics.insights?.recommendations || [];

    // Prepare closed question correlations
    const closedQuestionCorrelations = [
      { topics: form.analytics.topics?.cooccurrence || [] },
      { sentiment: form.analytics.sentiment?.topicCorrelations || [] }
    ];

    // Generate summary
    let summary = await this.summaryGenerator.generateAnalyticsSummary(
      form,
      responses,
      topTopics,
      sentimentDistribution,
      keyFindings,
      recommendations,
      representativeQuotes,
      closedQuestionCorrelations,
    );

    // Ensure non-empty summary (fallback if model returned empty text)
    if (!summary || !summary.trim()) {
      const sentimentLabel = (sentimentDistribution.positive ?? 0) > (sentimentDistribution.negative ?? 0)
        ? 'positive'
        : (sentimentDistribution.negative ?? 0) > (sentimentDistribution.positive ?? 0)
          ? 'negative'
          : 'neutral';
      const top3 = (topTopics || []).slice(0, 3).join(', ');
      summary = `Analysis of ${responses.length} responses to "${form.title}". Top themes: ${top3}. Overall sentiment is ${sentimentLabel}.`;
    }

    // Persist summary only (key findings are saved by the separate 'generate-findings' job)
    await this.formModel.updateOne(
      { _id: new Types.ObjectId(formId) },
      {
        $set: {
          'analytics.insights.summary': summary,
          'analytics.lastUpdated': new Date(),
        },
      }
    ).exec();

    console.log(`[AIGenerationConsumer][${taskId}] Summary generated and saved`);
    await this.progressService.publishProgress({
      taskId,
      type: 'progress',
      message: 'Summary saved',
      progress: 79,
    });

    job.progress(100);
    return { success: true, summaryLength: summary.length };
  }

  @Process({ name: 'generate-findings', concurrency: 3 })
  async handleFindings(job: Job<AIGenerationJobData>) {
    const { taskId, formId } = job.data;
    
    await this.progressService.publishProgress({
      taskId,
      type: 'progress',
      message: 'Generating key findings...',
      progress: 81,
    });

    // Load form and responses
    const form = await this.formModel.findById(formId).exec();
    if (!form || !form.analytics) {
      throw new Error('Form or analytics not found');
    }

    const responses = await this.responseModel.find({
      formId: new Types.ObjectId(formId),
      'metadata.processedForAnalytics': true,
    }).exec();

    // Extract data from form.analytics
    const topTopics = form.analytics.topics?.topTopics || [];
    const topicFrequencies = form.analytics.topics?.distribution || {};
    const sentimentDistribution = form.analytics.sentiment?.overall || { positive: 0, neutral: 0, negative: 0, averageScore: 0 };
    const representativeQuotes = form.analytics.quotes?.representative || [];
    const emotionalTones = form.analytics.sentiment?.emotionalTones || [];

    // Calculate data quality
    const dataQuality = {
      totalResponses: responses.length,
      validResponses: responses.filter(r => r.metadata?.processedForAnalytics).length,
      averageResponseLength: 0,
      completionRate: 0,
      textQuality: 'medium' as 'high' | 'medium' | 'low',
      overallScore: 0.7,
    };

    // Generate findings
    const findings = this.findingsGenerator.generateKeyFindings(
      responses,
      topTopics,
      topicFrequencies,
      sentimentDistribution,
      representativeQuotes,
      emotionalTones,
      dataQuality,
    );

    // Persist findings atomically
    await this.formModel.updateOne(
      { _id: new Types.ObjectId(formId) },
      {
        $set: {
          'analytics.insights.keyFindings': findings,
          'analytics.lastUpdated': new Date(),
        },
      }
    ).exec();

    console.log(`[AIGenerationConsumer][${taskId}] Findings generated and saved (${findings.length} findings)`);
    await this.progressService.publishProgress({
      taskId,
      type: 'progress',
      message: `Key findings saved (${findings.length})`,
      progress: 84,
    });

    job.progress(100);
    return { success: true, findingsCount: findings.length };
  }

  @Process({ name: 'generate-recommendations', concurrency: 3 })
  async handleRecommendations(job: Job<AIGenerationJobData>) {
    const { taskId, formId } = job.data;
    
    await this.progressService.publishProgress({
      taskId,
      type: 'progress',
      message: 'Generating recommendations...',
      progress: 86,
    });

    // Load form
    const form = await this.formModel.findById(formId).exec();
    if (!form || !form.analytics) {
      throw new Error('Form or analytics not found');
    }

    const responses = await this.responseModel.find({
      formId: new Types.ObjectId(formId),
      'metadata.processedForAnalytics': true,
    }).exec();

    // Extract data from form.analytics
    const sentimentDistribution = form.analytics.sentiment?.overall || { positive: 0, neutral: 0, negative: 0, averageScore: 0 };
    
    // Get canonical topics
    const canonicalTopicsSet = new Set<string>();
    responses.forEach(r => {
      const topics = r.metadata?.canonicalTopics || [];
      topics.forEach(t => canonicalTopicsSet.add(t));
    });
    const canonicalTopics = Array.from(canonicalTopicsSet);

    // Calculate data quality
    const dataQuality = {
      totalResponses: responses.length,
      validResponses: responses.filter(r => r.metadata?.processedForAnalytics).length,
      averageResponseLength: 0,
      completionRate: 0,
      textQuality: 'medium' as 'high' | 'medium' | 'low',
      overallScore: 0.7,
    };

    // Generate recommendations
    const recommendations = await this.recommendationsGenerator.generateRecommendations(
      sentimentDistribution,
      canonicalTopics,
      dataQuality,
    );

    // Persist recommendations atomically
    await this.formModel.updateOne(
      { _id: new Types.ObjectId(formId) },
      {
        $set: {
          'analytics.insights.recommendations': recommendations,
          'analytics.lastUpdated': new Date(),
        },
      }
    ).exec();

    console.log(`[AIGenerationConsumer][${taskId}] Recommendations generated and saved (${recommendations.length} recommendations)`);

    job.progress(100);
    return { success: true, recommendationsCount: recommendations.length };
  }

  @OnQueueFailed()
  onFailed(job: Job<AIGenerationJobData>, error: Error) {
    // eslint-disable-next-line no-console
    console.error(`[AI Generation] Job ${job.id} failed:`, error.message);
    this.deadLetterService.forwardWhenExhausted(QueueName.AI_GENERATION, job, error);
  }
}
